import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as r,c as i,d as e,e as o,b as d,w as t,f as h}from"./app-ff93bfbc.js";const c="/docs/assets/image/encryption-levels.png",l={},u=e("h1",{id:"auto-js-pro加密说明",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#auto-js-pro加密说明","aria-hidden":"true"},"#"),o(" Auto.js Pro加密说明")],-1),p=e("p",null,"Auto.js Pro支持在打包时对js文件进行加密，加密是通过多种方式将源码编译、加密为非明文文件。",-1),j=e("blockquote",null,[e("p",null,"注意: Auto.js Pro的加密并不包括对代码的混淆，建议在使用自带加密前再用其他混淆工具对代码进行一次混淆。可配置编译脚本在打包时自动执行混淆，具体可参考Pro 9.2.9以上版本中的示例 -> 项目与打包 -> 代码混淆。")],-1),_=e("h2",{id:"加密方式",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#加密方式","aria-hidden":"true"},"#"),o(" 加密方式")],-1),f=e("p",null,"每个引擎的加密实现方式有所不同，破解难度也会有所区别。在打包时可选择不同的加密等级，这里将说明不同加密方式的区别。",-1),q=e("figure",null,[e("img",{src:c,alt:"encryption-levels",tabindex:"0",loading:"lazy"}),e("figcaption",null,"encryption-levels")],-1),x=e("p",null,[e("strong",null,"encryption-levels")],-1),b=e("h3",{id:"node-js加密",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#node-js加密","aria-hidden":"true"},"#"),o(" Node.js加密")],-1),m=e("blockquote",null,[e("p",null,"还原难度：⭐️⭐️⭐️⭐️⭐️")],-1),N=h('<p>目前Node.js加密方式暂不支持mjs文件/ES Module，这些文件不会被加密，预计在9.5版本支持。</p><p>使用Node.js加密后运行错误，请先使用不加密方式打包，若加密后报错不加密正常，则可能是以下原因：</p><h4 id="模块文件未被识别为nodejs文件-被使用rhino引擎方式加密-导致无法运行。" tabindex="-1"><a class="header-anchor" href="#模块文件未被识别为nodejs文件-被使用rhino引擎方式加密-导致无法运行。" aria-hidden="true">#</a> 模块文件未被识别为nodejs文件，被使用Rhino引擎方式加密，导致无法运行。</h4><p>比如主模块文件是main.node.js，require了另一个模块文件mod.js，但是mod.js文件既没有以.node.js结尾，也没有用<code>&quot;nodejs&quot;;</code>文件头，因此在加密时被当成非nodejs文件使用快照、dex等加密方式加密。运行时自然会报错。</p><p>有两种方式解决：</p><ul><li>所有nodejs文件，都以.node.js结尾，或使用”nodejs”;`文件头</li><li>在project.json中，配置<code>&quot;type&quot;: &quot;node&quot;</code>，则项目下的所有文件默认是nodejs引擎（此时rhino引擎的文件需要加上<code>&quot;rhino;&quot;</code>的文件头）</li></ul><h4 id="node-modules下的文件未被识别为nodejs文件-被使用rhino引擎方式加密-导致无法运行。" tabindex="-1"><a class="header-anchor" href="#node-modules下的文件未被识别为nodejs文件-被使用rhino引擎方式加密-导致无法运行。" aria-hidden="true">#</a> node_modules下的文件未被识别为nodejs文件，被使用Rhino引擎方式加密，导致无法运行。</h4><p>原理同上，推荐在project.json中，配置<code>&quot;type&quot;: &quot;node&quot;</code>来解决这个问题。配置后项目下的所有文件默认是nodejs引擎，此时rhino引擎的文件需要加上<code>&quot;rhino;&quot;</code>的文件头。</p><h4 id="在64位手机上加密-在32位手机上运行" tabindex="-1"><a class="header-anchor" href="#在64位手机上加密-在32位手机上运行" aria-hidden="true">#</a> 在64位手机上加密，在32位手机上运行</h4><p>Node.js加密暂不支持跨CPU架构加密，因此只能在64位手机上加密只能在64位手机上运行；在32位手机上加密，CPU架构选择armeabi-v7a，则可以在64位、32位手机上运行。</p><h3 id="rhino普通加密" tabindex="-1"><a class="header-anchor" href="#rhino普通加密" aria-hidden="true">#</a> Rhino普通加密</h3><blockquote><p>还原难度：⭐️</p></blockquote><p>这种加密仅仅是将文件用某种方式加密，运行时需要解密，比较容易被还原。</p><h3 id="rhino-dex加密" tabindex="-1"><a class="header-anchor" href="#rhino-dex加密" aria-hidden="true">#</a> Rhino Dex加密</h3><blockquote><p>还原难度：⭐️⭐️</p></blockquote><p>这种加密方式将js文件编译为dex文件，一方面提升运行效率，另一方面提高了破解门槛。但dex本身仍然能看出代码逻辑，推荐再使用加固或dex2c等方式进一步保护代码。</p><h3 id="rhino-snapshot加密" tabindex="-1"><a class="header-anchor" href="#rhino-snapshot加密" aria-hidden="true">#</a> Rhino Snapshot加密</h3><blockquote><p>还原难度：⭐️⭐️⭐️</p></blockquote><p>这种加密方式将js文件编译为字节码文件，提升了运行效率和破解门槛。但字节码文件中的字符串等仍然为明文，因此不管使用什么加密，都推荐先使用混淆工具混淆。</p><h2 id="加密时或加密后遇到错误" tabindex="-1"><a class="header-anchor" href="#加密时或加密后遇到错误" aria-hidden="true">#</a> 加密时或加密后遇到错误</h2>',20),k=e("code",null,"ignore文件",-1);function P(g,v){const n=a("RouterLink");return r(),i("div",null,[u,p,j,_,e("p",null,[o("由于Auto.js Pro目前有两个引擎 ———— 旧引擎Rhino和新引擎Node.js。Pro 8以前的代码均是使用Rhino引擎，在Pro 9则可在文件最前面增加”nodejs”来使用Node.js引擎，同时启用全新的异步API（具体参见"),d(n,{to:"/v9/"},{default:t(()=>[o("Pro 9文档")]),_:1}),o("）。")]),f,q,x,b,m,e("p",null,[o("Node.js引擎目前只有一种加密方式，因此无论选择哪种加密等级结果没有不同。Node.js加密的还原难度较高，推荐使用新的Node.js引擎来编写你的代码，文档参见"),d(n,{to:"/v9/"},{default:t(()=>[o("第二代API文档")]),_:1}),o("。")]),N,e("p",null,[o("若加密过程遇到编译错误，可能是因为项目中包含web但js文件，这些文件也被参与加密导致。可以通过"),k,o("将其排除加密范围，具体参见"),d(n,{to:"/guide/project.html#ignore%E9%85%8D%E7%BD%AE"},{default:t(()=>[o("项目与配置")]),_:1}),o("。")])])}const A=s(l,[["render",P],["__file","encryption.html.vue"]]);export{A as default};
