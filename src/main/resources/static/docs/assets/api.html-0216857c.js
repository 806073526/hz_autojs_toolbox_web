import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as l,c as d,d as e,e as a,b as n,w as c,f as s}from"./app-ff93bfbc.js";const p={},u=s(`<h2 id="auto-mode" tabindex="-1"><a class="header-anchor" href="#auto-mode" aria-hidden="true">#</a> auto([mode])</h2><ul><li><code>mode</code> {string} 模式</li></ul><p>检查无障碍服务是否已经启用，如果没有启用则抛出异常并跳转到无障碍服务启用界面；同时设置无障碍模式为mode。mode的可选值为：</p><ul><li><code>fast</code> 快速模式。该模式下会启用控件缓存，从而选择器获取屏幕控件更快。对于需要快速的控件操作的脚本可以使用该模式，一般脚本则没有必要使用该函数。</li><li><code>normal</code> 正常模式，默认。</li></ul><p>如果不加mode参数，则为正常模式。</p><p>建议使用<code>auto.waitFor()</code>和<code>auto.setMode()</code>代替该函数，因为<code>auto()</code>函数如果无障碍服务未启动会停止脚本；而<code>auto.waitFor()</code>则会在在无障碍服务启动后继续运行。</p><p>示例：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">auto</span><span class="token punctuation">(</span><span class="token string">&quot;fast&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>示例2：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">auto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="auto-waitfor" tabindex="-1"><a class="header-anchor" href="#auto-waitfor" aria-hidden="true">#</a> auto.waitFor()</h2><p>检查无障碍服务是否已经启用，如果没有启用则跳转到无障碍服务启用界面，并等待无障碍服务启动；当无障碍服务启动后脚本会继续运行。</p><p>因为该函数是阻塞的，因此除非是有协程特性，否则不能在ui模式下运行该函数，建议在ui模式下使用<code>auto()</code>函数。</p><h2 id="auto-setmode-mode" tabindex="-1"><a class="header-anchor" href="#auto-setmode-mode" aria-hidden="true">#</a> auto.setMode(mode)</h2><ul><li><code>mode</code> {string} 模式</li></ul><p>设置无障碍模式为mode。mode的可选值为：</p><ul><li><code>fast</code> 快速模式。该模式下会启用控件缓存，从而选择器获取屏幕控件更快。对于需要快速的控件查看和操作的脚本可以使用该模式，一般脚本则没有必要使用该函数。</li><li><code>normal</code> 正常模式，默认。</li></ul><h2 id="auto-setflags-flags" tabindex="-1"><a class="header-anchor" href="#auto-setflags-flags" aria-hidden="true">#</a> auto.setFlags(flags)</h2><p><strong>[v4.1.0新增]</strong></p><ul><li><p><code>flags</code> {string} | {Array} 一些标志，来启用和禁用某些特性，包括：</p><ul><li><code>findOnUiThread</code> 使用该特性后，选择器搜索时会在主进程进行。该特性用于解决线程安全问题导致的次生问题，不过目前貌似已知问题并不是线程安全问题。</li><li><code>useUsageStats</code> 使用该特性后，将会以&quot;使用情况统计&quot;服务的结果来检测当前正在运行的应用包名（需要授予&quot;查看使用情况统计&quot;权限)。如果觉得currentPackage()返回的结果不太准确，可以尝试该特性。</li><li><code>useShell</code> 使用该特性后，将使用shell命令获取当前正在运行的应用的包名、活动名称，但是需要root权限。</li></ul></li></ul><p>启用有关automator的一些特性。例如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>auto<span class="token punctuation">.</span><span class="token function">setFlags</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;findOnUiThread&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;useShell&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="auto-service" tabindex="-1"><a class="header-anchor" href="#auto-service" aria-hidden="true">#</a> auto.service</h2><p><strong>[v4.1.0新增]</strong></p>`,24),h={href:"https://developer.android.com/reference/android/accessibilityservice/AccessibilityService",target:"_blank",rel:"noopener noreferrer"},m=e("p",null,[a("获取无障碍服务。如果无障碍服务没有启动，则返回"),e("code",null,"null"),a("。")],-1),k={href:"https://developer.android.com/reference/android/accessibilityservice/AccessibilityService",target:"_blank",rel:"noopener noreferrer"},b=e("h2",{id:"auto-windows",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#auto-windows","aria-hidden":"true"},"#"),a(" auto.windows")],-1),v=e("p",null,[e("strong",null,"[v4.1.0新增]")],-1),f=e("ul",null,[e("li",null,"{Array}")],-1),g={href:"https://developer.android.com/reference/android/view/accessibility/AccessibilityWindowInfo",target:"_blank",rel:"noopener noreferrer"},x=s('<p>该函数需要Android 5.0以上才能运行。</p><h2 id="auto-root" tabindex="-1"><a class="header-anchor" href="#auto-root" aria-hidden="true">#</a> auto.root</h2><p><strong>[v4.1.0新增]</strong></p><ul><li>{UiObject}</li></ul><p>当前窗口的布局根元素。如果无障碍服务未启动或者WindowFilter均返回false，则会返回<code>null</code>。</p><p>如果不设置windowFilter，则当前窗口即为活跃的窗口（获取到焦点、正在触摸的窗口）；如果设置了windowFilter，则获取的是过滤的窗口中的第一个窗口。</p><p>如果系统是Android5.0以下，则始终返回当前活跃的窗口的布局根元素。</p><h2 id="auto-rootinactivewindow" tabindex="-1"><a class="header-anchor" href="#auto-rootinactivewindow" aria-hidden="true">#</a> auto.rootInActiveWindow</h2><p><strong>[v4.1.0新增]</strong></p><ul><li>{UiObject}</li></ul><p>当前活跃的窗口（获取到焦点、正在触摸的窗口）的布局根元素。如果无障碍服务未启动则为<code>null</code>。</p><h2 id="auto-setwindowfilter-filter" tabindex="-1"><a class="header-anchor" href="#auto-setwindowfilter-filter" aria-hidden="true">#</a> auto.setWindowFilter(filter)</h2><p><strong>[v4.1.0新增]</strong></p>',13),w=e("code",null,"filter",-1),_={href:"https://developer.android.com/reference/android/view/accessibility/AccessibilityWindowInfo",target:"_blank",rel:"noopener noreferrer"},q=s(`<p>设置窗口过滤器。这个过滤器可以决定哪些窗口是目标窗口，并影响选择器的搜索。例如，如果想要选择器在所有窗口（包括状态栏、输入法等）中搜索，只需要使用以下代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>auto<span class="token punctuation">.</span><span class="token function">setWindowFilter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">window</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//不管是如何窗口，都返回true，表示在该窗口中搜索</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>又例如，当前使用了分屏功能，屏幕上有Auto.js和QQ两个应用，但我们只想选择器对QQ界面进行搜索，则：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>auto<span class="token punctuation">.</span><span class="token function">setWindowFilter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">window</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 对于应用窗口，他的title属性就是应用的名称，因此可以通过title属性来判断一个应用</span>
    <span class="token keyword">return</span> window<span class="token punctuation">.</span>title <span class="token operator">==</span> <span class="token string">&quot;QQ&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>选择器默认是在当前活跃的窗口中搜索，不会搜索诸如悬浮窗、状态栏之类的，使用WindowFilter则可以控制搜索的窗口。</p><p>需要注意的是， 如果WindowFilter返回的结果均为false，则选择器的搜索结果将为空。</p><p>另外setWindowFilter函数也会影响<code>auto.windowRoots</code>的结果。</p><p>该函数需要Android 5.0以上才有效。</p><h2 id="auto-windowroots" tabindex="-1"><a class="header-anchor" href="#auto-windowroots" aria-hidden="true">#</a> auto.windowRoots</h2><p><strong>[v4.1.0新增]</strong></p><ul><li>{Array}</li></ul><p>返回当前被WindowFilter过滤的窗口的布局根元素组成的数组。</p><p>如果系统是Android5.0以下，则始终返回当前活跃的窗口的布局根元素的数组。</p><h1 id="automator" tabindex="-1"><a class="header-anchor" href="#automator" aria-hidden="true">#</a> automator</h1><p>automator提供了一些模拟简单操作的函数，例如点击文字、模拟按键等。部分函数可以直接作为全局函数使用。</p><h2 id="click-text-i" tabindex="-1"><a class="header-anchor" href="#click-text-i" aria-hidden="true">#</a> click(text[, i])</h2><ul><li><code>text</code> {string} 要点击的文本</li><li><code>i</code> {number} 如果相同的文本在屏幕中出现多次，则i表示要点击第几个文本, i从0开始计算</li></ul><p>返回是否点击成功。当屏幕中并未包含该文本，或者该文本所在区域不能点击时返回false，否则返回true。</p><p>该函数可以点击大部分包含文字的按钮。例如微信主界面下方的&quot;微信&quot;, &quot;联系人&quot;, &quot;发现&quot;, &quot;我&quot;的按钮。<br> 通常与while同时使用以便点击按钮直至成功。例如:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token string">&quot;扫一扫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当不指定参数i时则会尝试点击屏幕上出现的所有文字text并返回是否全部点击成功。</p><p>i是从0开始计算的, 也就是, <code>click(&quot;啦啦啦&quot;, 0)</code>表示点击屏幕上第一个&quot;啦啦啦&quot;, <code>click(&quot;啦啦啦&quot;, 1)</code>表示点击屏幕上第二个&quot;啦啦啦&quot;。</p><blockquote><p>文本所在区域指的是，从文本处向其父视图寻找，直至发现一个可点击的部件为止。</p></blockquote><h2 id="click-left-top-bottom-right" tabindex="-1"><a class="header-anchor" href="#click-left-top-bottom-right" aria-hidden="true">#</a> click(left, top, bottom, right)</h2><ul><li><code>left</code> {number} 要点击的长方形区域左边与屏幕左边的像素距离</li><li><code>top</code> {number} 要点击的长方形区域上边与屏幕上边的像素距离</li><li><code>bottom</code> {number} 要点击的长方形区域下边与屏幕下边的像素距离</li><li><code>right</code> {number} 要点击的长方形区域右边与屏幕右边的像素距离</li></ul><p><strong>注意，该函数一般只用于录制的脚本中使用，在自己写的代码中使用该函数一般不要使用该函数。</strong></p><p>点击在指定区域的控件。当屏幕中并未包含与该区域严格匹配的区域，或者该区域不能点击时返回false，否则返回true。</p><p>有些按钮或者部件是图标而不是文字（例如发送朋友圈的照相机图标以及QQ下方的消息、联系人、动态图标），这时不能通过<code>click(text, i)</code>来点击，可以通过描述图标所在的区域来点击。left, bottom, top, right描述的就是点击的区域。</p><p>至于要定位点击的区域，可以在悬浮窗使用布局分析工具查看控件的bounds属性。</p><p>通过无障碍服务录制脚本会生成该语句。</p><h2 id="longclick-text-i" tabindex="-1"><a class="header-anchor" href="#longclick-text-i" aria-hidden="true">#</a> longClick(text[, i])</h2><ul><li><code>text</code> {string} 要长按的文本</li><li><code>i</code> {number} 如果相同的文本在屏幕中出现多次，则i表示要长按第几个文本, i从0开始计算</li></ul><p>返回是否点击成功。当屏幕中并未包含该文本，或者该文本所在区域不能点击时返回false，否则返回true。</p><p>当不指定参数i时则会尝试点击屏幕上出现的所有文字text并返回是否全部长按成功。</p><h2 id="scrollup-i" tabindex="-1"><a class="header-anchor" href="#scrollup-i" aria-hidden="true">#</a> scrollUp([i])</h2><ul><li><code>i</code> {number} 要滑动的控件序号</li></ul><p>找到第i+1个可滑动控件上滑或<strong>左滑</strong>。返回是否操作成功。屏幕上没有可滑动的控件时返回false。</p><p>另外不加参数时<code>scrollUp()</code>会寻找面积最大的可滑动的控件上滑或左滑，例如微信消息列表等。</p><p>参数为一个整数i时会找到第i + 1个可滑动控件滑动。例如<code>scrollUp(0)</code>为滑动第一个可滑动控件。</p><h2 id="scrolldown-i" tabindex="-1"><a class="header-anchor" href="#scrolldown-i" aria-hidden="true">#</a> scrollDown([i])</h2><ul><li><code>i</code> {number} 要滑动的控件序号</li></ul><p>找到第i+1个可滑动控件下滑或<strong>右滑</strong>。返回是否操作成功。屏幕上没有可滑动的控件时返回false。</p><p>另外不加参数时<code>scrollUp()</code>会寻找面积最大的可滑动的控件下滑或右滑。</p><p>参数为一个整数i时会找到第i + 1个可滑动控件滑动。例如<code>scrollUp(0)</code>为滑动第一个可滑动控件。</p><h2 id="settext-i-text" tabindex="-1"><a class="header-anchor" href="#settext-i-text" aria-hidden="true">#</a> setText([i, ]text)</h2><ul><li><code>i</code> {number} 表示要输入的为第i + 1个输入框</li><li><code>text</code> {string} 要输入的文本</li></ul><p>返回是否输入成功。当找不到对应的文本框时返回false。</p><p>不加参数i则会把所有输入框的文本都置为text。例如<code>setText(&quot;测试&quot;)</code>。</p><p>这里的输入文本的意思是，把输入框的文本置为text，而不是在原来的文本上追加。</p><h2 id="input-i-text" tabindex="-1"><a class="header-anchor" href="#input-i-text" aria-hidden="true">#</a> input([i, ]text)</h2><ul><li><code>i</code> {number} 表示要输入的为第i + 1个输入框</li><li><code>text</code> {string} 要输入的文本</li></ul><p>返回是否输入成功。当找不到对应的文本框时返回false。</p><p>不加参数i则会把所有输入框的文本追加内容text。例如<code>input(&quot;测试&quot;)</code>。</p><h2 id="automator-takescreenshot" tabindex="-1"><a class="header-anchor" href="#automator-takescreenshot" aria-hidden="true">#</a> automator.takeScreenshot()</h2>`,54),j={href:"//www.wuyunai.com/docs",target:"_blank",rel:"noopener noreferrer"},y=s(`<ul><li>返回 {Image}</li></ul><p>使用无障碍权限截图，返回一个Image对象。</p><p>相比起images模块申请截图权限截图，该函数不需要额外权限，但是有以下限制：</p><ul><li>截图频率限制。系统限制截图最多一秒一次，否则抛出异常</li><li>需要Android 11及以上版本</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>$auto<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> capture <span class="token operator">=</span> $automator<span class="token punctuation">.</span><span class="token function">takeScreenshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
$images<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>capture<span class="token punctuation">,</span> <span class="token string">&quot;../capture.png&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="automator-switchtoinputmethod-packagename" tabindex="-1"><a class="header-anchor" href="#automator-switchtoinputmethod-packagename" aria-hidden="true">#</a> automator.switchToInputMethod(packageName)</h2><p><strong>[<a href="">Pro 8.8.0新增</a>]</strong></p><ul><li><code>packageName</code> {string} 输入法包名</li><li>返回 {boolean}</li></ul><p>切换到指定输入法，返回是否成功。失败的情况有以下可能：</p><ul><li>指定包名的输入法不存在或未启用</li><li>系统返回切换输入法失败</li></ul><p>此函数需要Android 11及以上。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 切换到搜狗输入法</span>
$automator<span class="token punctuation">.</span><span class="token function">switchToInputMethod</span><span class="token punctuation">(</span><span class="token string">&#39;com.sohu.inputmethod.sogou&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="automator-headsethook" tabindex="-1"><a class="header-anchor" href="#automator-headsethook" aria-hidden="true">#</a> automator.headsetHook()</h2><p><strong>[<a href="">Pro 8.8.0新增</a>]</strong></p><ul><li>返回 {boolean}</li></ul><p>模拟耳机键，返回是否执行成功。用于挂断、接听电话，播放、暂停音乐。</p><h2 id="auto-clearcache" tabindex="-1"><a class="header-anchor" href="#auto-clearcache" aria-hidden="true">#</a> auto.clearCache()</h2><p><strong>[v9.0.14新增]</strong></p><p>清空无障碍缓存。当屏幕上的控件已经出现但是选择器始终无法找到该控件，可能是缓存没有刷新，此时可调用<code>auto.clearCache()</code>来清空控件缓存。另外，从9.0版本开始，<code>findOne()</code>等函数在长时间找不到时也会自动清空缓存。</p><h2 id="rect" tabindex="-1"><a class="header-anchor" href="#rect" aria-hidden="true">#</a> Rect</h2><p><code>UiObject.bounds()</code>, <code>UiObject.boundsInParent()</code>返回的对象。表示一个长方形(范围)。</p><h3 id="rect-left" tabindex="-1"><a class="header-anchor" href="#rect-left" aria-hidden="true">#</a> Rect.left</h3><ul><li>{number}</li></ul><p>长方形左边界的x坐标、</p><h3 id="rect-right" tabindex="-1"><a class="header-anchor" href="#rect-right" aria-hidden="true">#</a> Rect.right</h3><ul><li>{number}</li></ul><p>长方形右边界的x坐标、</p><h3 id="rect-top" tabindex="-1"><a class="header-anchor" href="#rect-top" aria-hidden="true">#</a> Rect.top</h3><ul><li>{number}</li></ul><p>长方形上边界的y坐标、</p><h3 id="rect-bottom" tabindex="-1"><a class="header-anchor" href="#rect-bottom" aria-hidden="true">#</a> Rect.bottom</h3><ul><li>{number}</li></ul><p>长方形下边界的y坐标、</p><h3 id="rect-centerx" tabindex="-1"><a class="header-anchor" href="#rect-centerx" aria-hidden="true">#</a> Rect.centerX()</h3><ul><li>返回 {number}</li></ul><p>长方形中点x坐标。</p><h3 id="rect-centery" tabindex="-1"><a class="header-anchor" href="#rect-centery" aria-hidden="true">#</a> Rect.centerY()</h3><ul><li>返回 {number}</li></ul><p>长方形中点y坐标。</p><h3 id="rect-width" tabindex="-1"><a class="header-anchor" href="#rect-width" aria-hidden="true">#</a> Rect.width()</h3><ul><li>返回 {number}</li></ul><p>长方形宽度。通常可以作为控件宽度。</p><h3 id="rect-height" tabindex="-1"><a class="header-anchor" href="#rect-height" aria-hidden="true">#</a> Rect.height()</h3><ul><li>返回 {number}</li></ul><p>长方形高度。通常可以作为控件高度。</p><h3 id="rect-contains-r" tabindex="-1"><a class="header-anchor" href="#rect-contains-r" aria-hidden="true">#</a> Rect.contains(r)</h3>`,46),A=e("code",null,"r",-1),F=e("p",null,"返回是否包含另一个长方形r。包含指的是，长方形r在该长方形的里面(包含边界重叠的情况)。",-1),R=e("h3",{id:"rect-intersect-r",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#rect-intersect-r","aria-hidden":"true"},"#"),a(" Rect.intersect(r)")],-1),W=e("code",null,"r",-1),I=e("p",null,"返回是否和另一个长方形相交。",-1);function U(S,Q){const t=i("ExternalLinkIcon"),o=i("RouterLink");return l(),d("div",null,[u,e("ul",null,[e("li",null,[a("{"),e("a",h,[a("AccessibilityService"),n(t)]),a("}")])]),m,e("p",null,[a("参见"),e("a",k,[a("AccessibilityService"),n(t)]),a("。")]),b,v,f,e("p",null,[a("当前所有窗口("),e("a",g,[a("AccessibilityWindowInfo"),n(t)]),a(")的数组，可能包括状态栏、输入法、当前应用窗口，弹出窗口、悬浮窗、分屏应用窗口等。可以分别获取每个窗口的布局信息。")]),x,e("ul",null,[e("li",null,[w,a(" {Function} 参数为窗口("),e("a",_,[a("AccessibilityWindowInfo"),n(t)]),a(")，返回值为Boolean的函数。")])]),q,e("p",null,[e("strong",null,[a("["),e("a",j,[a("Pro 8.8.0新增"),n(t)]),a("]")])]),y,e("ul",null,[e("li",null,[A,a(" {"),n(o,{to:"/v8/automator/api.html#rect"},{default:c(()=>[a("Rect")]),_:1}),a("}")])]),F,R,e("ul",null,[e("li",null,[W,a(" {"),n(o,{to:"/v8/automator/api.html#rect"},{default:c(()=>[a("Rect")]),_:1}),a("}")])]),I])}const N=r(p,[["render",U],["__file","api.html.vue"]]);export{N as default};
